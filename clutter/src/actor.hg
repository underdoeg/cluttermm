/* Copyright (C) 2007 The cluttermm Development Team
 *
 * This library is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public
 * License as published by the Free Software Foundation; either
 * version 2.1 of the License, or (at your option) any later version.
 *
 * This library is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with this library; if not, write to the Free
 * Software Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
 */

#include <glibmm/object.h>
#include <pangomm/context.h>
#include <cluttermm/color.h>
#include <cluttermm/scriptable.h>
#include <cluttermm/shader.h>
#include <cluttermm/types.h> // For Event*
#include <clutter/clutter.h> // For ClutterActorBox
 
_DEFS(cluttermm,clutter)
_PINCLUDE(glibmm/private/object_p.h)


namespace Clutter
{

class ActorBox
{
  _CLASS_BOXEDTYPE_STATIC(ActorBox, ClutterActorBox)
public:
  ActorBox(Unit x1, Unit y1, Unit x2, Unit y2);

  _MEMBER_GET(x1, x1, Unit, ClutterUnit)
  _MEMBER_SET(x1, x1, Unit, ClutterUnit)
  _MEMBER_GET(y1, y1, Unit, ClutterUnit)
  _MEMBER_SET(y1, y1, Unit, ClutterUnit)
  _MEMBER_GET(x2, x2, Unit, ClutterUnit)
  _MEMBER_SET(x2, x2, Unit, ClutterUnit)
  _MEMBER_GET(y2, y2, Unit, ClutterUnit)
  _MEMBER_SET(y2, y2, Unit, ClutterUnit)
};

_WRAP_ENUM(ActorFlags, ClutterActorFlags)

class Actor : public Glib::Object, public Scriptable
{
  _CLASS_GOBJECT(Actor, ClutterActor, CLUTTER_ACTOR, Glib::Object, GObject)
  _DERIVES_INITIALLY_UNOWNED()
  _IMPLEMENTS_INTERFACE(Scriptable)

protected:
  _CTOR_DEFAULT()

public:
  //There is no create() because this is an abstract base class.
  //_WRAP_CREATE()

  void set_flags(ActorFlags flags);
  void unset_flags(ActorFlags flags);
  _MEMBER_GET(flags, flags, ActorFlags, guint32)

  bool is_mapped() const;
  bool is_realized() const;
  bool is_visible() const;
  bool is_reactive() const;

  _WRAP_METHOD(void show(), clutter_actor_show)
  _WRAP_METHOD(void show_all(), clutter_actor_show_all)
  _WRAP_METHOD(void hide(), clutter_actor_hide)
  _WRAP_METHOD(void hide_all(), clutter_actor_hide_all)
  _WRAP_METHOD(void realize(), clutter_actor_realize)
  _WRAP_METHOD(void unrealize(), clutter_actor_unrealize)
  _WRAP_METHOD(void paint(), clutter_actor_paint)
  _WRAP_METHOD(void queue_redraw(), clutter_actor_queue_redraw)
  _WRAP_METHOD(void queue_relayout(), clutter_actor_queue_relayout)

#m4 dnl // Those are varargs convenience functions for C coders
  _IGNORE(clutter_actor_animate, clutter_actor_animate_with_alpha, clutter_actor_animate_with_timeline)

  //TODO: Check that we don't want to wrap this: _WRAP_METHOD(void destroy(), clutter_actor_destroy)
  //_IGNORE(clutter_actor_destroy)

  _WRAP_METHOD(Glib::RefPtr<Pango::Context> get_pango_context(),
               clutter_actor_get_pango_context, refreturn)
  _WRAP_METHOD(Glib::RefPtr<const Pango::Context> get_pango_context() const,
               clutter_actor_get_pango_context, refreturn, constversion)
  _WRAP_METHOD(Glib::RefPtr<Pango::Context> create_pango_context(),
               clutter_actor_create_pango_context)

  _WRAP_METHOD(Glib::RefPtr<Actor> get_stage(), clutter_actor_get_stage)
  _WRAP_METHOD(Glib::RefPtr<const Actor> get_stage() const, clutter_actor_get_stage)
#m4 _CONVERSION(`const Geometry&', `const ClutterGeometry*', `($3).gobj()')
  _WRAP_METHOD(void set_geometry(const Geometry& geometry), clutter_actor_set_geometry)
  _WRAP_METHOD_DOCS_ONLY(clutter_actor_get_geometry)
  Geometry get_geometry() const;
  //_WRAP_METHOD(void get_coords(int *x_1, int *y_1, int *x_2, int *y_2) const, clutter_actor_get_coords)
  _WRAP_METHOD(void set_size(int width, int height), clutter_actor_set_size)
  _WRAP_METHOD(void set_sizeu(Unit width, Unit height), clutter_actor_set_sizeu)
  _WRAP_METHOD(void get_position(int& x, int& y), clutter_actor_get_position)
  _WRAP_METHOD(void get_positionu(Unit& x, Unit& y), clutter_actor_get_positionu)
  _WRAP_METHOD(void set_position(int x, int y), clutter_actor_set_position)
  _WRAP_METHOD(void set_positionu(Unit x, Unit y), clutter_actor_set_positionu)
  //_WRAP_METHOD(void get_abs_position(int& x, int& y) const, clutter_actor_get_abs_position)
  _WRAP_METHOD(guint get_width() const, clutter_actor_get_width)
  _WRAP_METHOD(Unit get_widthu() const, clutter_actor_get_widthu)
  _WRAP_METHOD(guint get_height() const, clutter_actor_get_height)
  _WRAP_METHOD(Unit get_heightu() const, clutter_actor_get_heightu)
  _WRAP_METHOD(void set_width(guint width), clutter_actor_set_width)
  _WRAP_METHOD(void set_widthu(Unit width), clutter_actor_set_widthu)
  _WRAP_METHOD(void set_height(guint height), clutter_actor_set_height)
  _WRAP_METHOD(void set_heightu(Unit height), clutter_actor_set_heightu)

  _WRAP_METHOD(void set_x(int x), clutter_actor_set_x)
  _WRAP_METHOD(void set_xu(Unit x), clutter_actor_set_xu)
  _WRAP_METHOD(int get_x() const, clutter_actor_get_x)
  _WRAP_METHOD(Unit get_xu() const, clutter_actor_get_xu)
  _WRAP_METHOD(void set_y(int y), clutter_actor_set_y)
  _WRAP_METHOD(void set_yu(Unit y), clutter_actor_set_yu)
  _WRAP_METHOD(int get_y() const, clutter_actor_get_y)
  _WRAP_METHOD(Unit get_yu() const, clutter_actor_get_yu)
  _WRAP_METHOD(void set_reactive(bool reactive = true), clutter_actor_set_reactive)
  _WRAP_METHOD(bool get_reactive() const, clutter_actor_get_reactive)

  _WRAP_METHOD(void set_rotation(RotateAxis axis, double angle, int x, int y, int z), clutter_actor_set_rotation)
  _WRAP_METHOD(void set_rotationx(RotateAxis axis, Fixed angle, int x, int y, int z), clutter_actor_set_rotationx)
  _WRAP_METHOD(void set_rotationu(RotateAxis axis, double angle, Unit x, Unit y, Unit z), clutter_actor_set_rotationu)
  _WRAP_METHOD(double get_rotation(RotateAxis axis, int& x, int& y, int& z) const, clutter_actor_get_rotation)
  _WRAP_METHOD(Fixed get_rotationx(RotateAxis axis, int& x, int& y, int& z) const, clutter_actor_get_rotationx)
  _WRAP_METHOD(double get_rotationu(RotateAxis axis, Unit& x, Unit& y, Unit& z) const, clutter_actor_get_rotationu)
  _WRAP_METHOD(void set_opacity (guint8 opacity), clutter_actor_set_opacity)
  _WRAP_METHOD(guint8 get_opacity() const, clutter_actor_get_opacity)
  _WRAP_METHOD(void set_name(const gchar           *name), clutter_actor_set_name)
  _WRAP_METHOD(Glib::ustring get_name() const, clutter_actor_get_name)
  _WRAP_METHOD(guint32 get_gid() const, clutter_actor_get_gid)
  _WRAP_METHOD(void set_clip(int xoff, int yoff, int width, int height), clutter_actor_set_clip)
  _WRAP_METHOD(void get_clip(int& xoff, int& yoff, int& width, int& height), clutter_actor_get_clip)
  _WRAP_METHOD(void set_clipu(Unit xoff, Unit yoff, Unit width, Unit height), clutter_actor_set_clipu)
  _WRAP_METHOD(void get_clipu(Unit& xoff, Unit& yoff, Unit& width, Unit& height), clutter_actor_get_clipu)
  _WRAP_METHOD(void remove_clip(), clutter_actor_remove_clip)
  _WRAP_METHOD(bool has_clip() const, clutter_actor_has_clip)
  _WRAP_METHOD(void set_parent(const Glib::RefPtr<Actor>& parent), clutter_actor_set_parent)
  _WRAP_METHOD(Glib::RefPtr<Actor> get_parent(), clutter_actor_get_parent, refreturn)
  _WRAP_METHOD(Glib::RefPtr<const Actor> get_parent() const, clutter_actor_get_parent, refreturn, constversion)
  _WRAP_METHOD(void reparent(const Glib::RefPtr<Actor>& new_parent), clutter_actor_reparent)
  _WRAP_METHOD(void unparent(), clutter_actor_unparent)
  _WRAP_METHOD(void raise(const Glib::RefPtr<Actor>& below), clutter_actor_raise)
  _WRAP_METHOD(void lower(const Glib::RefPtr<Actor>& above), clutter_actor_lower)
  _WRAP_METHOD(void raise_top (), clutter_actor_raise_top)
  _WRAP_METHOD(void lower_bottom(), clutter_actor_lower_bottom)

  _WRAP_METHOD(Glib::RefPtr<Shader> get_shader(), clutter_actor_get_shader)
  _WRAP_METHOD(Glib::RefPtr<const Shader> get_shader() const, clutter_actor_get_shader, constversion)
  _WRAP_METHOD(void set_shader(const Glib::RefPtr<Shader>& shader), clutter_actor_set_shader)
  _WRAP_METHOD_DOCS_ONLY(clutter_actor_set_shader_param)
  template <class ParamType> void set_shader_param(const Glib::ustring& param, const ParamType& value);
  _IGNORE(clutter_actor_set_shader_param_int, clutter_actor_set_shader_param_float)
  //_WRAP_METHOD_DOCS_ONLY(clutter_actor_get_paint_area)
  //ActorBox get_paint_area() const;
  _WRAP_METHOD(bool is_rotated() const, clutter_actor_is_rotated)
  _WRAP_METHOD(bool is_scaled() const, clutter_actor_is_scaled)
  _WRAP_METHOD_DOCS_ONLY(clutter_actor_get_allocation_vertices)
  void get_allocation_vertices(Vertex vertices[4]) const;
  _WRAP_METHOD_DOCS_ONLY(clutter_actor_get_allocation_vertices)
  void get_allocation_vertices(const Glib::RefPtr<Actor>& ancestor, Vertex vertices[4]) const;
  _WRAP_METHOD_DOCS_ONLY(clutter_actor_get_abs_allocation_vertices)
  void get_abs_allocation_vertices(Vertex vertices[4]) const;
  _WRAP_METHOD_DOCS_ONLY(clutter_actor_get_allocation_box)
  ActorBox get_allocation_box() const;
#m4 _CONVERSION(`const ActorBox&', `const ClutterActorBox*',`($3).gobj()')
  _WRAP_METHOD(void allocate(const ActorBox& box, bool absolute_origin_changed), clutter_actor_allocate)
  _WRAP_METHOD(void allocate(bool absolute_origin_changed), clutter_actor_allocate_preferred_size)

#m4 _CONVERSION(`const Vertex&',`ClutterVertex*',`const_cast<ClutterVertex*>(($3).gobj())')
#m4 _CONVERSION(`Vertex&',`ClutterVertex*',`($3).gobj()')
  _WRAP_METHOD(void apply_relative_transform_to_point(const Glib::RefPtr<Actor>& ancestor, const Vertex& point, Vertex& vertex) const, clutter_actor_apply_relative_transform_to_point)
  _WRAP_METHOD_DOCS_ONLY(clutter_actor_get_allocation_vertices)
  void apply_relative_transform_to_point(const Vertex& point, Vertex& vertex) const;

  _WRAP_METHOD(void get_preferred_size(Unit& min_width_p, Unit& min_height_p, Unit& natural_width_p, Unit& natural_height_p) const, clutter_actor_get_preferred_size)
  _WRAP_METHOD(void get_preferred_width(Unit for_height, Unit& min_width_p, Unit& natural_width_p) const, clutter_actor_get_preferred_width)
  _WRAP_METHOD(void get_preferred_height(Unit for_width, Unit& min_height_p, Unit& natural_height_p) const, clutter_actor_get_preferred_height)
  _WRAP_METHOD(guint8 get_paint_opacity() const, clutter_actor_get_paint_opacity)
  _WRAP_METHOD(bool get_paint_visibility() const, clutter_actor_get_paint_visibility)
  _WRAP_METHOD(void move_anchor_point_from_gravity(Gravity gravity), clutter_actor_move_anchor_point_from_gravity)
  _WRAP_METHOD(void move_anchor_point(int anchor_x, int anchor_y), clutter_actor_move_anchor_point)
  _WRAP_METHOD(void move_anchor_pointu(Unit anchor_x, Unit anchor_y), clutter_actor_move_anchor_pointu)

  _WRAP_METHOD(bool get_fixed_position_set() const, clutter_actor_get_fixed_position_set)
  _WRAP_METHOD(void set_fixed_position_set(bool is_set), clutter_actor_set_fixed_position_set)
  _WRAP_METHOD(void get_transformed_position(int& x, int& y) const, clutter_actor_get_transformed_position)
  _WRAP_METHOD(void get_transformed_positionu(Unit& x, Unit& y) const, clutter_actor_get_transformed_positionu)
  _WRAP_METHOD(void get_transformed_size(guint& width, guint& height) const, clutter_actor_get_transformed_size)
  _WRAP_METHOD(void get_transformed_sizeu(Unit& width, Unit& height) const, clutter_actor_get_transformed_sizeu)
  _WRAP_METHOD(void get_allocation_coords(int& x1, int& y1, int& x2, int& y2) const, clutter_actor_get_allocation_coords)
  _WRAP_METHOD_DOCS_ONLY(clutter_actor_get_allocation_geometry)
  Geometry get_allocation_geometry() const;

  _WRAP_METHOD(void set_depth(int depth), clutter_actor_set_depth)
  _WRAP_METHOD(void set_depthu(Unit depth), clutter_actor_set_depthu)
  _WRAP_METHOD(int get_depth() const, clutter_actor_get_depth)
  _WRAP_METHOD(Unit get_depthu() const, clutter_actor_get_depthu)
  _WRAP_METHOD(void set_scalex(Fixed scale_x, Fixed scale_y), clutter_actor_set_scalex)
  _WRAP_METHOD(void set_scale(double scale_x, double scale_y), clutter_actor_set_scale)
  _WRAP_METHOD(void get_scalex(Fixed& scale_x, Fixed& scale_y) const, clutter_actor_get_scalex)
  _WRAP_METHOD(void get_scale(double& scale_x, double& scale_y) const, clutter_actor_get_scale)

  //_WRAP_METHOD(void get_abs_size(guint& width, guint& height) const, clutter_actor_get_abs_size)
  _WRAP_METHOD(void get_size(guint& width, guint& height) const, clutter_actor_get_size)
  _WRAP_METHOD(void get_sizeu(Unit& width, Unit& height) const, clutter_actor_get_sizeu)
  _WRAP_METHOD(void move_by(int dx, int dy), clutter_actor_move_by)
  _WRAP_METHOD(void move_byu(Unit dx, Unit dy), clutter_actor_move_byu)

  _WRAP_METHOD(void apply_transform_to_point(const Vertex& point, Vertex& vertex) const, clutter_actor_apply_transform_to_point)
  _WRAP_METHOD(void transform_stage_point(Unit x, Unit y, Unit& x_out, Unit& y_out) const, clutter_actor_transform_stage_point)

  _WRAP_METHOD(bool event(ClutterEvent* event, bool capture), clutter_actor_event)
  _WRAP_METHOD(static Glib::RefPtr<Actor> get_actor_by_gid(guint32 id), clutter_get_actor_by_gid)

  _WRAP_METHOD(void set_anchor_point(int anchor_x, int anchor_y), clutter_actor_set_anchor_point)
  _WRAP_METHOD(void get_anchor_point(int& anchor_x, int& anchor_y) const, clutter_actor_get_anchor_point)
  _WRAP_METHOD(void set_anchor_pointu(Unit anchor_x, Unit anchor_y), clutter_actor_set_anchor_pointu)
  _WRAP_METHOD(void get_anchor_pointu(Unit& anchor_x, Unit& anchor_y), clutter_actor_get_anchor_pointu)
  _WRAP_METHOD(void set_anchor_point_from_gravity(ClutterGravity gravity), clutter_actor_set_anchor_point_from_gravity)

  // These are needed by custom container implementations and therefore public.
  _WRAP_METHOD(void pick(const Color& color), clutter_actor_pick)
  _WRAP_METHOD(bool should_pick_paint() const, clutter_actor_should_pick_paint)

  _WRAP_METHOD(void grab_key_focus(), clutter_actor_grab_key_focus)

// signals
  _WRAP_SIGNAL(bool button_press_event(ButtonEvent* event), "button_press_event")
  _WRAP_SIGNAL(bool button_release_event(ButtonEvent* event), "button_release_event")
  _WRAP_SIGNAL(bool motion_event(MotionEvent* event), "motion_event")
  _WRAP_SIGNAL(bool leave_event(CrossingEvent* event), "leave_event")
  _WRAP_SIGNAL(void show(), "show")
  _WRAP_SIGNAL(void hide(), "hide")
  _WRAP_SIGNAL(void destroy(), "destroy")
  _WRAP_SIGNAL(bool key_release_event(KeyEvent* event), "key_release_event")
  _WRAP_SIGNAL(bool enter_event(CrossingEvent* event), "enter_event")
  _WRAP_SIGNAL(bool event(Event* event), "event")
  _WRAP_SIGNAL(void focus_out(), "focus_out")
  _WRAP_SIGNAL(void focus_in(), "focus_in")
#m4 _CONVERSION(`ClutterActor*', `const Glib::RefPtr<Actor>&', `Glib::wrap(($3),true)')
  _WRAP_SIGNAL(void parent_set(const Glib::RefPtr<Actor>& old_parent), "parent_set")
  _WRAP_SIGNAL(bool scroll_event(ScrollEvent* event), "scroll_event")
  _WRAP_SIGNAL(bool key_press_event(KeyEvent* event), "key_press_event")
  _WRAP_SIGNAL(bool captured_event(Event* event), "captured_event")
  _WRAP_SIGNAL(void paint(), "paint")
  _WRAP_SIGNAL(void realize(), "realize")
  _WRAP_SIGNAL(void unrealize(), "unrealize")

  _WRAP_PROPERTY("allocation", ActorBox)
  _WRAP_PROPERTY("anchor-x", int)
  _WRAP_PROPERTY("anchor-y", int)
  _WRAP_PROPERTY("clip", Geometry)
  _WRAP_PROPERTY("depth", int)
  _WRAP_PROPERTY("fixed-position-set", bool)
  _WRAP_PROPERTY("fixed-x", Unit)
  _WRAP_PROPERTY("fixed-y", Unit)
  _WRAP_PROPERTY("has-clip", bool)
  _WRAP_PROPERTY("height", int)
  _WRAP_PROPERTY("min-height", Unit)
  _WRAP_PROPERTY("min-height-set", bool)
  _WRAP_PROPERTY("min-width", Unit)
  _WRAP_PROPERTY("min-width-set", bool)
  _WRAP_PROPERTY("opacity", guint8)
  _WRAP_PROPERTY("reactive", bool)
  _WRAP_PROPERTY("request-mode", RequestMode)
  _WRAP_PROPERTY("rotation-angle-x", double)
  _WRAP_PROPERTY("rotation-angle-y", double)
  _WRAP_PROPERTY("rotation-angle-z", double)
  _WRAP_PROPERTY("rotation-center-x", Vertex)
  _WRAP_PROPERTY("rotation-center-y", Vertex)
  _WRAP_PROPERTY("rotation-center-z", Vertex)
  _WRAP_PROPERTY("scale-x", double)
  _WRAP_PROPERTY("scale-y", double)
  _WRAP_PROPERTY("show-on-set-parent", bool)
  _WRAP_PROPERTY("visible", bool)
  _WRAP_PROPERTY("width", int)
  _WRAP_PROPERTY("x", int)
  _WRAP_PROPERTY("y", int)

protected:
  _WRAP_METHOD(void set_shader_param_value(const Glib::ustring& param, const Glib::ValueBase& value),
               clutter_actor_set_shader_param)

  _WRAP_VFUNC(void show_all(), "show_all")
  _WRAP_VFUNC(void hide_all(), "hide_all")

  #m4 _CONVERSION(`const ClutterColor*', `const Color&', `Color(const_cast<ClutterColor*>($3), true)')
  // TODO: I think we need to hand-code the vfuncs if we need to handle
  // the ClutterUnit* being NULL.
  #m4 _CONVERSION(`ClutterUnit*', `Unit&', `*($3)')
  #m4 _CONVERSION(`const ClutterActorBox*', `const ActorBox&', `Glib::wrap($3)')
  _WRAP_VFUNC(void pick(const Color& color), "pick")
  _WRAP_VFUNC(void get_preferred_width(Unit for_height, Unit& min_width_p, Unit& natural_width_p) const, "get_preferred_width")
  _WRAP_VFUNC(void get_preferred_height(Unit for_width, Unit& min_height_p, Unit& natural_height_p) const, "get_preferred_height")
  _WRAP_VFUNC(void allocate(const ActorBox& box, bool absolute_origin_changed), "allocate")

};

#ifndef DOXYGEN_SHOULD_SKIP_THIS
template <class ParamType>
void Actor::set_shader_param(const Glib::ustring& param, const ParamType& value)
{
  Glib::Value<ParamType> param_value;
  param_value.init(Glib::Value<ParamType>::value_type());

  param_value.set(value);
  this->set_shader_param_value(param, param_value);
}
#endif /* DOXYGEN_SHOULD_SKIP_THIS */

} // namespace Clutter
